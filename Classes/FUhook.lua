-- mt hook class 
--[[local mtHook = {}
mtHook.__index = mtHook

function mtHook.initializeMtHook(mtMethod, method)
    local self = setmetatable({}, mtHook) 

    self._mtMethod = mtMethod or error("metamethod required #1 argument")
    self._method = method or error("method required #2 argument")
  

    return self
end

function mtHook:callHook()
    if self. 
end

local s = mtHook.createMtHook("__namecall", "GetFullName")

function mtHook:logCalls(mtHook)

end]]





-- function hook class 
local fuHook = {}
fuHook.__index = fuHook

function fuHook.new(_function: Function)
    local self = setmetatable({}, fuHook)

    self.toHook = _function
    self.hooks = {}

    print("step 1")

    return self 
end

-- if rawhooking gets detected they detect hooks universally.
function fuHook:rawHook(hookCalls: number)
    self.toHook = self.toHook or error("#1 passed argument must be a function")
    self.hooks = self.hooks or {}
    hookCalls = hookCalls or 1

    local calls = calls or 0
    

    local hookThread = task.spawn(function()
        if type(self.toHook) == "function" then
            self.hooks.oldFunction = nil
            self.hooks.oldFunction = hookfunction(self.toHook, newcclosure(function(...)
                print(calls, " inside hookfunction")
                calls += 1
                return self.hooks.oldFunction(...)
            end))
        end
    end)

    while calls >= hookCalls do
        task.wait(1)
        print("raw hook ran " .. tostring(calls) .. " times")
        coroutine.close(hookThread)
        break    
    end 
end



local new = fuHook.new(math.random)
local testftwo = new:rawHook()

print(new, testftwo)


-- deep search class 
