-- mt hook class 
--[[local mtHook = {}
mtHook.__index = mtHook

function mtHook.initializeMtHook(mtMethod, method)
    local self = setmetatable({}, mtHook) 

    self._mtMethod = mtMethod or error("metamethod required #1 argument")
    self._method = method or error("method required #2 argument")
  

    return self
end

function mtHook:callHook()
    if self. 
end

local s = mtHook.createMtHook("__namecall", "GetFullName")

function mtHook:logCalls(mtHook)

end]]





-- function hook class 
local fuHook = {}
fuHook.__index = fuHook

function fuHook.new(_function)
    local self = setmetatable({}, fuHook)

    self.toHook = _function
    self.hooks = {}

    print("step 1")

    return self 
end

function fuHook:correctType()
    print("step 2")
    return (type(self.toHook) == "function") 
end


-- if rawhooking gets detected they detect hooks universally.
function fuHook:rawHook()
    local calls = 0
    self.hooks = self.hooks or {}

    if fuHook:correctType() then
        print("step 3")
        self.hooks.oldFunction = nil
        self.hooks.oldFunction = hookfunction(self.toHook, function(...)
            calls += 1
            return self.hooks.oldFunction(...)
        end)

        print("step 4")

        if  calls >= 1 then 
            print("raw hook ran " .. tostring(calls) .. " times")
            self.hooks.oldFunction = nil
        end
        print("step 5")
    end
end

return fuHook


-- deep search class 
